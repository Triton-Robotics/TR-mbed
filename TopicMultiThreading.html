<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TR-mbed: Eigen and multi-threading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TR-mbed<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">TR-mbed</a></li><li class="navelem"><a class="el" href="UserManual_Generalities.html">General topics</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Eigen and multi-threading</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="TopicMultiThreading_MakingEigenMT"></a>
Make Eigen run in parallel</h1>
<p>Some Eigen's algorithms can exploit the multiple cores present in your hardware. To this end, it is enough to enable OpenMP on your compiler, for instance:</p><ul>
<li>GCC: <code>-fopenmp</code> </li>
<li>ICC: <code>-openmp</code> </li>
<li>MSVC: check the respective option in the build properties.</li>
</ul>
<p>You can control the number of threads that will be used using either the OpenMP API or Eigen's API using the following priority: </p><div class="fragment"><div class="line">OMP_NUM_THREADS=<a class="code hl_variable" href="BiCGSTAB__simple_8cpp.html#a5150192f625f4d7970d61169b9567f39">n</a> ./my_program</div>
<div class="line">omp_set_num_threads(<a class="code hl_variable" href="BiCGSTAB__simple_8cpp.html#a5150192f625f4d7970d61169b9567f39">n</a>);</div>
<div class="line"><a class="code hl_function" href="namespaceEigen.html#af9cd17c2fe18204239cd11c88c120b50">Eigen::setNbThreads</a>(<a class="code hl_variable" href="BiCGSTAB__simple_8cpp.html#a5150192f625f4d7970d61169b9567f39">n</a>);</div>
<div class="ttc" id="aBiCGSTAB__simple_8cpp_html_a5150192f625f4d7970d61169b9567f39"><div class="ttname"><a href="BiCGSTAB__simple_8cpp.html#a5150192f625f4d7970d61169b9567f39">n</a></div><div class="ttdeci">int n</div><div class="ttdef"><b>Definition</b> BiCGSTAB_simple.cpp:1</div></div>
<div class="ttc" id="anamespaceEigen_html_af9cd17c2fe18204239cd11c88c120b50"><div class="ttname"><a href="namespaceEigen.html#af9cd17c2fe18204239cd11c88c120b50">Eigen::setNbThreads</a></div><div class="ttdeci">void setNbThreads(int v)</div><div class="ttdef"><b>Definition</b> Parallelizer.h:72</div></div>
</div><!-- fragment --><p> Unless <code>setNbThreads</code> has been called, Eigen uses the number of threads specified by OpenMP. You can restore this behavior by calling <code>setNbThreads(0);</code>. You can query the number of threads that will be used with: </p><div class="fragment"><div class="line"><a class="code hl_variable" href="BiCGSTAB__simple_8cpp.html#a5150192f625f4d7970d61169b9567f39">n</a> = <a class="code hl_function" href="namespaceEigen.html#a9aca97d83e21b91a04ec079360dfffeb">Eigen::nbThreads</a>( );</div>
<div class="ttc" id="anamespaceEigen_html_a9aca97d83e21b91a04ec079360dfffeb"><div class="ttname"><a href="namespaceEigen.html#a9aca97d83e21b91a04ec079360dfffeb">Eigen::nbThreads</a></div><div class="ttdeci">int nbThreads()</div><div class="ttdef"><b>Definition</b> Parallelizer.h:63</div></div>
</div><!-- fragment --><p> You can disable Eigen's multi threading at compile time by defining the <a class="el" href="TopicPreprocessorDirectives.html#TopicPreprocessorDirectivesPerformance">EIGEN_DONT_PARALLELIZE </a> preprocessor token.</p>
<p>Currently, the following algorithms can make use of multi-threading:</p><ul>
<li>general dense matrix - matrix products</li>
<li><a class="el" href="classEigen_1_1PartialPivLU.html" title="LU decomposition of a matrix with partial pivoting, and related features.">PartialPivLU</a></li>
<li>row-major-sparse * dense vector/matrix products</li>
<li><a class="el" href="classEigen_1_1ConjugateGradient.html" title="A conjugate gradient solver for sparse (or dense) self-adjoint problems.">ConjugateGradient</a> with <code>Lower|Upper</code> as the <code>UpLo</code> template parameter.</li>
<li><a class="el" href="classEigen_1_1BiCGSTAB.html" title="A bi conjugate gradient stabilized solver for sparse square problems.">BiCGSTAB</a> with a row-major sparse matrix format.</li>
<li><a class="el" href="classEigen_1_1LeastSquaresConjugateGradient.html" title="A conjugate gradient solver for sparse (or dense) least-square problems.">LeastSquaresConjugateGradient</a></li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>On most OS it is <b>very important</b> to limit the number of threads to the number of physical cores, otherwise significant slowdowns are expected, especially for operations involving dense matrices.</dd></dl>
<p>Indeed, the principle of hyper-threading is to run multiple threads (in most cases 2) on a single core in an interleaved manner. However, Eigen's matrix-matrix product kernel is fully optimized and already exploits nearly 100% of the CPU capacity. Consequently, there is no room for running multiple such threads on a single core, and the performance would drops significantly because of cache pollution and other sources of overheads. At this stage of reading you're probably wondering why Eigen does not limit itself to the number of physical cores? This is simply because OpenMP does not allow to know the number of physical cores, and thus Eigen will launch as many threads as <em>cores</em> reported by OpenMP.</p>
<h1><a class="anchor" id="TopicMultiThreading_UsingEigenWithMT"></a>
Using Eigen in a multi-threaded application</h1>
<p>In the case your own application is multithreaded, and multiple threads make calls to Eigen, then you have to initialize Eigen by calling the following routine <b>before</b> creating the threads: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="bench__move__semantics_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="namespaceEigen.html#a820c0e0460934cc17eb6dacbad54a9f5">Eigen::initParallel</a>();</div>
<div class="line">  </div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="abench__move__semantics_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="bench__move__semantics_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> bench_move_semantics.cpp:51</div></div>
<div class="ttc" id="anamespaceEigen_html_a820c0e0460934cc17eb6dacbad54a9f5"><div class="ttname"><a href="namespaceEigen.html#a820c0e0460934cc17eb6dacbad54a9f5">Eigen::initParallel</a></div><div class="ttdeci">void initParallel()</div><div class="ttdef"><b>Definition</b> Parallelizer.h:53</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>With Eigen 3.3, and a fully C++11 compliant compiler (i.e., <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables">thread-safe static local variable initialization</a>), then calling <code><a class="el" href="namespaceEigen.html#a820c0e0460934cc17eb6dacbad54a9f5">initParallel()</a></code> is optional.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that all functions generating random matrices are <b>not</b> re-entrant nor thread-safe. Those include <a class="el" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">DenseBase::Random()</a>, and <a class="el" href="classEigen_1_1DenseBase.html#a39046dff78acbcb389ad0b018e587c8e">DenseBase::setRandom()</a> despite a call to <code><a class="el" href="namespaceEigen.html#a820c0e0460934cc17eb6dacbad54a9f5">Eigen::initParallel()</a></code>. This is because these functions are based on <code>std::rand</code> which is not re-entrant. For thread-safe random generator, we recommend the use of c++11 random generators (<a class="el" href="classEigen_1_1DenseBase.html#a08224b09985b372f108850b1c605feed">example </a>) or <code>boost::random</code>.</dd></dl>
<p>In the case your application is parallelized with OpenMP, you might want to disable Eigen's own parallelization as detailed in the previous section.</p>
<dl class="section warning"><dt>Warning</dt><dd>Using OpenMP with custom scalar types that might throw exceptions can lead to unexpected behaviour in the event of throwing. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
