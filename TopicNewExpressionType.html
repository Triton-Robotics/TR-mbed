<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TR-mbed: Adding a new expression type</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TR-mbed
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">index</a></li><li class="navelem"><a class="el" href="UserManual_CustomizingEigen.html">Extending/Customizing Eigen</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Adding a new expression type </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section warning"><dt>Warning</dt><dd>Disclaimer: this page is tailored to very advanced users who are not afraid of dealing with some Eigen's internal aspects. In most cases, a custom expression can be avoided by either using custom <a class="el" href="CommonCwiseUnaryOps_8h.html#ab8047e72312c629685f323ffa253de80">unary</a> or <a class="el" href="CommonCwiseBinaryOps_8h.html#aa3921b9acd51555d36f1ed85efb5fd89">binary</a> functors, while extremely complex matrix manipulations can be achieved by a nullary functors as described in the <a class="el" href="TopicCustomizing_NullaryExpr.html">previous page</a>.</dd></dl>
<p>This page describes with the help of an example how to implement a new light-weight expression type in Eigen. This consists of three parts: the expression type itself, a traits class containing compile-time information about the expression, and the evaluator class which is used to evaluate the expression to a matrix.</p>
<p><b>TO</b> <b>DO:</b> Write a page explaining the design, with details on vectorization etc., and refer to that page here.</p>
<p>\eigenAutoToc</p>
<h1><a class="anchor" id="TopicSetting"></a>
The setting</h1>
<p>A circulant matrix is a matrix where each column is the same as the column to the left, except that it is cyclically shifted downwards. For example, here is a 4-by-4 circulant matrix: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{bmatrix} 1 &amp; 8 &amp; 4 &amp; 2 \\ 2 &amp; 1 &amp; 8 &amp; 4 \\ 4 &amp; 2 &amp; 1 &amp; 8 \\ 8 &amp; 4 &amp; 2 &amp; 1 \end{bmatrix} \]" src="form_20.png"/>
</p>
<p> A circulant matrix is uniquely determined by its first column. We wish to write a function <code>makeCirculant</code> which, given the first column, returns an expression representing the circulant matrix.</p>
<p>For simplicity, we restrict the <code>makeCirculant</code> function to dense matrices. It may make sense to also allow arrays, or sparse matrices, but we will not do so here. We also do not want to support vectorization.</p>
<h1><a class="anchor" id="TopicPreamble"></a>
Getting started</h1>
<p>We will present the file implementing the <code>makeCirculant</code> function part by part. We start by including the appropriate header files and forward declaring the expression class, which we will call <code>Circulant</code>. The <code>makeCirculant</code> function will return an object of this type. The class <code>Circulant</code> is in fact a class template; the template argument <code>ArgType</code> refers to the type of the vector passed to the <code>makeCirculant</code> function.</p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="TopicTraits"></a>
The traits class</h1>
<p>For every expression class <code>X</code>, there should be a traits class <code>Traits&lt;X&gt;</code> in the <code><a class="el" href="namespaceEigen_1_1internal.html">Eigen::internal</a></code> namespace containing information about <code>X</code> known as compile time.</p>
<p>As explained in <a class="el" href="TopicNewExpressionType.html#TopicSetting">The setting</a>, we designed the <code>Circulant</code> expression class to refer to dense matrices. The entries of the circulant matrix have the same type as the entries of the vector passed to the <code>makeCirculant</code> function. The type used to index the entries is also the same. Again for simplicity, we will only return column-major matrices. Finally, the circulant matrix is a square matrix (number of rows equals number of columns), and the number of rows equals the number of rows of the column vector passed to the <code>makeCirculant</code> function. If this is a dynamic-size vector, then the size of the circulant matrix is not known at compile-time.</p>
<p>This leads to the following code:</p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="TopicExpression"></a>
The expression class</h1>
<p>The next step is to define the expression class itself. In our case, we want to inherit from <code><a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a></code> in order to expose the interface for dense matrices. In the constructor, we check that we are passed a column vector (see <a class="el" href="TopicAssertions.html">Assertions</a>) and we store the vector from which we are going to build the circulant matrix in the member variable <code>m_arg</code>. Finally, the expression class should compute the size of the corresponding circulant matrix. As explained above, this is a square matrix with as many columns as the vector used to construct the matrix.</p>
<p><b>TO</b> <b>DO:</b> What about the <code>Nested</code> typedef? It seems to be necessary; is this only temporary?</p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="TopicEvaluator"></a>
The evaluator</h1>
<p>The last big fragment implements the evaluator for the <code>Circulant</code> expression. The evaluator computes the entries of the circulant matrix; this is done in the <code></code>.coeff() member function. The entries are computed by finding the corresponding entry of the vector from which the circulant matrix is constructed. Getting this entry may actually be non-trivial when the circulant matrix is constructed from a vector which is given by a complicated expression, so we use the evaluator which corresponds to the vector.</p>
<p>The <code>CoeffReadCost</code> constant records the cost of computing an entry of the circulant matrix; we ignore the index computation and say that this is the same as the cost of computing an entry of the vector from which the circulant matrix is constructed.</p>
<p>In the constructor, we save the evaluator for the column vector which defined the circulant matrix. We also save the size of that vector; remember that we can query an expression object to find the size but not the evaluator.</p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="TopicEntry"></a>
The entry point</h1>
<p>After all this, the <code>makeCirculant</code> function is very simple. It simply creates an expression object and returns it.</p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="TopicMain"></a>
A simple main function for testing</h1>
<p>Finally, a short <code>main</code> function that shows how the <code>makeCirculant</code> function can be called.</p>
<div class="fragment"></div><!-- fragment --><p>If all the fragments are combined, the following output is produced, showing that the program works as expected:</p>
<div class="fragment"></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
